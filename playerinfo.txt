// ==UserScript==
// @name         BattleMetrics Rust Analytics
// @namespace    http://tampermonkey.net/
// @version      1.0.1
// @description  analytics tool for BattleMetrics that displays Rust player statistics including total playtime, first seen date, and their players top servers by hours
// @author       jlaiii
// @match        https://www.battlemetrics.com/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function () {
    'use strict';

    const INFO_BOX_ID = 'bmt-info-box';
    const BUTTON_ID = 'bmt-hour-button';
    const TOGGLE_BUTTON_ID = 'bmt-toggle-button';
    const RELOAD_FLAG = 'bmt_force_recalc_after_load';
    const MENU_VISIBLE_KEY = 'bmt_menu_visible';

    let currentPlayerID = null;
    let lastURL = window.location.href;
    let cachedPlayerData = null;
    let currentServerPage = 0;
    let allTopServers = [];
    let autoPullEnabled = true;
    let debugConsoleEnabled = false;
    let autoPullInterval = null;
    
    // Settings management
    const loadSettings = () => {
        try {
            const settings = JSON.parse(localStorage.getItem('bma_settings') || '{}');
            autoPullEnabled = settings.autoPullEnabled !== false; // Default to true
            debugConsoleEnabled = settings.debugConsoleEnabled === true; // Default to false
        } catch (e) {
            autoPullEnabled = true;
            debugConsoleEnabled = false;
        }
    };

    const saveSettings = () => {
        const settings = {
            autoPullEnabled,
            debugConsoleEnabled
        };
        localStorage.setItem('bma_settings', JSON.stringify(settings));
    };

    // Load settings on startup
    loadSettings();

    // Debug Console System
    class DebugConsole {
        constructor() {
            this.logs = [];
            this.enabled = debugConsoleEnabled;
            this.maxLogs = 1000;
            this.version = '1.0.1';
        }

        saveDebugSetting(enabled) {
            debugConsoleEnabled = enabled;
            this.enabled = enabled;
            saveSettings();
        }

        log(level, message, data = null) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp,
                level,
                message,
                data: data ? JSON.stringify(data, null, 2) : null,
                url: window.location.href,
                userAgent: navigator.userAgent
            };

            this.logs.push(logEntry);
            
            // Keep only last maxLogs entries
            if (this.logs.length > this.maxLogs) {
                this.logs = this.logs.slice(-this.maxLogs);
            }

            // Always log to browser console if debug is enabled
            if (this.enabled) {
                const consoleMessage = `[BMA Debug ${level.toUpperCase()}] ${message}`;
                switch (level) {
                    case 'error':
                        console.error(consoleMessage, data);
                        break;
                    case 'warn':
                        console.warn(consoleMessage, data);
                        break;
                    case 'info':
                        console.info(consoleMessage, data);
                        break;
                    default:
                        console.log(consoleMessage, data);
                }
            }

            // Update debug console display if it exists
            this.updateDebugDisplay();
        }

        error(message, data = null) {
            this.log('error', message, data);
        }

        warn(message, data = null) {
            this.log('warn', message, data);
        }

        info(message, data = null) {
            this.log('info', message, data);
        }

        debug(message, data = null) {
            this.log('debug', message, data);
        }

        exportLogs() {
            const exportData = {
                version: this.version,
                exportTime: new Date().toISOString(),
                playerID: currentPlayerID,
                totalLogs: this.logs.length,
                logs: this.logs
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bma_debug_log_${currentPlayerID || 'unknown'}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            this.info('Debug logs exported', { filename: a.download, logCount: this.logs.length });
        }

        clearLogs() {
            this.logs = [];
            this.updateDebugDisplay();
            this.updateDebugStats();
            this.info('Debug logs cleared');
        }

        updateDebugDisplay() {
            this.updateDebugStats();
            
            const debugList = document.getElementById('debug-console-list');
            if (!debugList) return;

            const recentLogs = this.logs.slice(-50).reverse(); // Show last 50 logs
            
            if (recentLogs.length === 0) {
                debugList.innerHTML = '<div style="opacity: 0.7; font-style: italic; color: #6c757d;">No debug logs available</div>';
                return;
            }

            let debugHTML = '';
            recentLogs.forEach(log => {
                const levelColor = {
                    'error': '#dc3545',
                    'warn': '#ffc107',
                    'info': '#17a2b8',
                    'debug': '#6c757d'
                }[log.level] || '#6c757d';

                const time = new Date(log.timestamp).toLocaleTimeString();
                
                debugHTML += `
                    <div style="padding: 5px; margin-bottom: 3px; border-left: 3px solid ${levelColor}; background: rgba(255,255,255,0.05); font-size: 11px;">
                        <div style="color: ${levelColor}; font-weight: bold;">
                            [${log.level.toUpperCase()}] ${time}
                        </div>
                        <div style="color: white; margin: 2px 0;">
                            ${log.message}
                        </div>
                        ${log.data ? `<div style="color: #6c757d; font-family: monospace; font-size: 10px; max-height: 100px; overflow-y: auto; white-space: pre-wrap;">${log.data}</div>` : ''}
                    </div>
                `;
            });

            debugList.innerHTML = debugHTML;
        }

        updateDebugStats() {
            const statsDiv = document.getElementById('debug-stats');
            if (!statsDiv) return;

            const stats = this.getStats();
            const oldestTime = stats.oldestLog ? new Date(stats.oldestLog).toLocaleString() : 'N/A';
            
            statsDiv.innerHTML = `
                Total Logs: ${stats.totalLogs} | 
                Errors: ${stats.errorCount} | 
                Warnings: ${stats.warnCount} | 
                Info: ${stats.infoCount} | 
                Debug: ${stats.debugCount}
                ${stats.oldestLog ? `<br>Oldest: ${oldestTime}` : ''}
            `;
        }

        getStats() {
            const stats = {
                totalLogs: this.logs.length,
                errorCount: this.logs.filter(l => l.level === 'error').length,
                warnCount: this.logs.filter(l => l.level === 'warn').length,
                infoCount: this.logs.filter(l => l.level === 'info').length,
                debugCount: this.logs.filter(l => l.level === 'debug').length,
                oldestLog: this.logs.length > 0 ? this.logs[0].timestamp : null,
                newestLog: this.logs.length > 0 ? this.logs[this.logs.length - 1].timestamp : null
            };
            return stats;
        }

        getLogsAsText() {
            const header = `BattleMetrics Rust Analytics v${this.version} Debug Logs
Export Time: ${new Date().toISOString()}
Player ID: ${currentPlayerID || 'Unknown'}
Total Logs: ${this.logs.length}
URL: ${window.location.href}
User Agent: ${navigator.userAgent}

=== DEBUG LOGS ===
`;

            const logsText = this.logs.map(log => {
                const timestamp = new Date(log.timestamp).toLocaleString();
                let logLine = `[${log.level.toUpperCase()}] ${timestamp}: ${log.message}`;
                if (log.data) {
                    logLine += `\nData: ${log.data}`;
                }
                return logLine;
            }).join('\n\n');

            return header + logsText;
        }
    }

    // Initialize debug console
    const debugConsole = new DebugConsole();

    // Enhanced debug logging for playerinfo script
    const debugLog = (level, message, data = null) => {
        debugConsole.log(level, message, data);
    };
    
    // Auto-pull functionality
    const startAutoPull = () => {
        if (autoPullInterval) return; // Already running
        
        debugLog('info', 'Starting auto-pull functionality');
        
        // Check immediately if we're on a player page
        checkAndPullPlayerData();
        
        // Set up interval to check for player page changes
        autoPullInterval = setInterval(() => {
            checkAndPullPlayerData();
        }, 2000); // Check every 2 seconds
    };

    const stopAutoPull = () => {
        if (autoPullInterval) {
            clearInterval(autoPullInterval);
            autoPullInterval = null;
            debugLog('info', 'Auto-pull functionality stopped');
        }
    };

    const checkAndPullPlayerData = () => {
        const currentURL = window.location.href;
        
        // Check if we're on a player page
        if (!currentURL.includes('/players/')) {
            // Clear current player ID if we're not on a player page
            if (currentPlayerID) {
                currentPlayerID = null;
                removeResults();
            }
            return;
        }
        
        // Extract player ID from URL
        const playerID = currentURL.split('/players/')[1]?.split('/')[0];
        if (!playerID) {
            return;
        }
        
        // Check if this is a new player or URL changed
        if (currentPlayerID !== playerID || lastURL !== currentURL) {
            debugLog('info', `Auto-pulling data for player ${playerID}`);
            currentPlayerID = playerID;
            lastURL = currentURL;
            
            // Check if data is available before processing
            const dataScript = document.getElementById('storeBootstrap');
            if (dataScript) {
                try {
                    const pageData = JSON.parse(dataScript.textContent);
                    if (pageData?.state?.players?.serverInfo?.[playerID]) {
                        // Data is ready, process immediately
                        setTimeout(() => {
                            processDataInstantly();
                        }, 500);
                    } else {
                        // Data not ready, wait a bit longer
                        setTimeout(() => {
                            processDataInstantly();
                        }, 2000);
                    }
                } catch (e) {
                    // Error parsing data, wait and try
                    setTimeout(() => {
                        processDataInstantly();
                    }, 2000);
                }
            } else {
                // No data script yet, wait longer
                setTimeout(() => {
                    processDataInstantly();
                }, 3000);
            }
        }
    };

    // Log script startup
    debugLog('info', 'BattleMetrics Rust Analytics v1.0.1 loaded', {
        url: window.location.href,
        userAgent: navigator.userAgent,
        autoPullEnabled,
        debugConsoleEnabled
    });
    
    // Debug console system initialized
    debugLog('debug', 'Debug console system initialized');

    const removeResults = () => {
        const infoBox = document.getElementById(INFO_BOX_ID);
        if (infoBox) infoBox.remove();
        // Reset pagination state
        currentServerPage = 0;
        allTopServers = [];
    };

    const isMenuVisible = () => {
        return localStorage.getItem(MENU_VISIBLE_KEY) !== 'false';
    };

    const setMenuVisibility = (visible) => {
        localStorage.setItem(MENU_VISIBLE_KEY, visible.toString());
        updateButtonsVisibility();
    };

    const updateButtonsVisibility = () => {
        const button = document.getElementById(BUTTON_ID);
        const infoBox = document.getElementById(INFO_BOX_ID);
        const visible = isMenuVisible();

        if (button) {
            button.style.display = visible ? 'block' : 'none';
        }
        if (infoBox) {
            infoBox.style.display = visible ? 'block' : 'none';
        }

        updateToggleButton();
    };

    const updateToggleButton = () => {
        const toggleBtn = document.getElementById(TOGGLE_BUTTON_ID);
        if (toggleBtn) {
            const visible = isMenuVisible();
            toggleBtn.textContent = visible ? '✕' : '☰';
            toggleBtn.title = visible ? 'Hide Rust Analytics Menu' : 'Show Rust Analytics Menu';
        }
    };

    const createToggleButton = () => {
        // Remove existing toggle button if it exists
        const existingToggleBtn = document.getElementById(TOGGLE_BUTTON_ID);
        if (existingToggleBtn) existingToggleBtn.remove();

        const toggleBtn = document.createElement("button");
        toggleBtn.id = TOGGLE_BUTTON_ID;
        toggleBtn.onclick = () => {
            const currentlyVisible = isMenuVisible();
            setMenuVisibility(!currentlyVisible);
        };

        Object.assign(toggleBtn.style, {
            position: "fixed",
            top: "20px",
            right: "20px",
            zIndex: "10000", // Higher than main button
            padding: "8px 12px",
            backgroundColor: "#6c757d",
            color: "#fff",
            border: "none",
            borderRadius: "5px",
            cursor: "pointer",
            fontSize: "14px",
            fontWeight: "bold"
        });

        document.body.appendChild(toggleBtn);
        updateToggleButton();
    };

    const showInfoBox = (playerName, playerID, totalHours, firstSeenData, topServers, totalRustServers = 0, isError = false, errorMessage = "", earliestFirstSeen = null) => {
        removeResults();

        const infoBox = document.createElement("div");
        infoBox.id = INFO_BOX_ID;

        // Store all servers for pagination
        allTopServers = topServers;
        currentServerPage = 0;

        // Create collapsible sections
        let content = `
            <div style="border-bottom: 2px solid rgba(255,255,255,0.2); padding-bottom: 12px; margin-bottom: 15px;">
                <div style="font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 8px;">
                    Rust Player Information
                </div>
                <div style="font-size: 14px; opacity: 0.9;">
                    <strong>Player:</strong> ${playerName}<br>
                    <small>ID: ${playerID}</small>
                </div>
            </div>
        `;

        if (isError) {
            content += `
                <div style="background: rgba(220, 53, 69, 0.2); border: 1px solid #dc3545; border-radius: 5px; padding: 10px; margin-bottom: 15px;">
                    <div style="color: #ff6b6b; font-weight: bold;">Error</div>
                    <div style="font-size: 13px; margin-top: 5px;">${errorMessage}</div>
                </div>
            `;
        } else {
            // Calculate daily average if we have first seen date
            let dailyAverageText = '';
            if (earliestFirstSeen) {
                const firstSeenDate = new Date(earliestFirstSeen);
                const now = new Date();
                const daysSinceFirstSeen = Math.max(1, Math.ceil((now - firstSeenDate) / (1000 * 60 * 60 * 24)));
                const dailyAverage = parseFloat(totalHours) / daysSinceFirstSeen;
                dailyAverageText = `<div style="font-size: 11px; opacity: 0.8;">Average ${dailyAverage.toFixed(2)} hours a day</div>`;
            }

            // Hours section
            content += `
                <div style="background: rgba(40, 167, 69, 0.2); border: 1px solid #28a745; border-radius: 5px; padding: 12px; margin-bottom: 15px;">
                    <div style="font-size: 16px; font-weight: bold; color: #28a745; margin-bottom: 5px;">
                        True Rust Hours: ${totalHours}
                    </div>
                    <div style="font-size: 11px; opacity: 0.8;">Total time spent across all Rust servers combined</div>
                    ${dailyAverageText}
                </div>
            `;

            // First seen section
            content += `
                <div style="background: rgba(0, 123, 255, 0.2); border: 1px solid #007bff; border-radius: 5px; padding: 12px; margin-bottom: 15px;">
                    <div style="font-size: 14px; font-weight: bold; color: #007bff; margin-bottom: 8px;">
                        First Time Seen on Rust
                    </div>
                    <div style="font-size: 13px; margin-bottom: 3px;">${firstSeenData.relative}</div>
                    ${firstSeenData.full ? `<div style="font-size: 11px; opacity: 0.8;">${firstSeenData.full}</div>` : ''}
                </div>
            `;

            // Rust servers count section
            content += `
                <div style="background: rgba(255, 193, 7, 0.2); border: 1px solid #ffc107; border-radius: 5px; padding: 12px; margin-bottom: 15px;">
                    <div style="font-size: 14px; font-weight: bold; color: #ffc107; margin-bottom: 5px;">
                        Total Rust Servers Played: ${totalRustServers}
                    </div>
                </div>
            `;

            // Top servers section
            content += `
                <div style="background: rgba(23, 162, 184, 0.2); border: 1px solid #17a2b8; border-radius: 5px; padding: 12px;">
                    <div style="font-size: 13px; font-weight: bold; color: #17a2b8; margin-bottom: 10px; cursor: pointer;" onclick="toggleServers()">
                        Top Servers by Hours <span id="servers-toggle">▼</span>
                    </div>
                    <div id="servers-list" style="display: block;">
            `;

            if (topServers.length === 0) {
                content += `<div style="font-size: 13px; opacity: 0.8;">No Rust server hours found.</div>`;
            } else {
                content += `<div id="servers-content"></div>`;

                // Add pagination controls if more than 10 servers
                if (topServers.length > 10) {
                    content += `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
                            <button id="prev-btn" style="background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                                ← Back
                            </button>
                            <span id="page-info" style="font-size: 11px; opacity: 0.8;"></span>
                            <button id="next-btn" style="background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                                Next →
                            </button>
                        </div>
                    `;
                }
            }

            content += `
                    </div>
                </div>
            `;

            // Copy info button at bottom
            content += `
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="copyPlayerInfo()" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 12px;">
                        Copy Player Info
                    </button>
                </div>
                
                <!-- Settings Section -->
                <div style="background: rgba(108, 117, 125, 0.2); border: 1px solid #6c757d; border-radius: 5px; padding: 12px; margin-top: 15px;">
                    <div style="font-size: 13px; font-weight: bold; color: #6c757d; margin-bottom: 10px; cursor: pointer;" onclick="toggleSettings()">
                        Settings <span id="settings-toggle">▶</span>
                    </div>
                    <div id="settings-content" style="display: none;">
                        <div style="margin-bottom: 8px;">
                            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">
                                <input type="checkbox" id="auto-pull-toggle" ${autoPullEnabled ? 'checked' : ''} style="margin-right: 8px;">
                                Auto-pull profile data
                            </label>
                            <div style="font-size: 10px; opacity: 0.7; margin-left: 20px; margin-top: 2px;">
                                Automatically load player data when visiting profile pages
                            </div>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">
                                <input type="checkbox" id="debug-console-toggle" ${debugConsoleEnabled ? 'checked' : ''} style="margin-right: 8px;">
                                Enable debug console
                            </label>
                            <div style="font-size: 10px; opacity: 0.7; margin-left: 20px; margin-top: 2px;">
                                Show debug console with detailed logging
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Debug Console Section -->
                <div id="debug-console-section" style="background: rgba(52, 58, 64, 0.3); border: 1px solid #495057; border-radius: 5px; padding: 12px; margin-top: 15px; ${debugConsoleEnabled ? 'display: block;' : 'display: none;'}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="font-size: 13px; font-weight: bold; color: #495057;">
                            Debug Console
                        </div>
                        <div>
                            <button onclick="copyDebugLogs()" style="background: #17a2b8; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; margin-right: 5px;">
                                Copy Text
                            </button>
                            <button onclick="exportDebugLogs()" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; margin-right: 5px;">
                                Export
                            </button>
                            <button onclick="clearDebugLogs()" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; margin-right: 5px;">
                                Clear
                            </button>
                            <button onclick="testDebugConsole()" style="background: #6c757d; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">
                                Test
                            </button>
                        </div>
                    </div>
                    <div id="debug-stats" style="font-size: 10px; color: #6c757d; margin-bottom: 8px; padding: 5px; background: rgba(0,0,0,0.2); border-radius: 3px;">
                        Loading debug statistics...
                    </div>
                    <div id="debug-console-list" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); border-radius: 3px; padding: 8px; font-family: monospace;">
                        <div style="opacity: 0.7; font-style: italic; color: #6c757d;">Loading debug logs...</div>
                    </div>
                </div>
                
                <!-- Version Info -->
                <div style="text-align: center; padding: 10px; border-top: 1px solid rgba(255,255,255,0.2); margin-top: 15px;">
                    <div style="font-size: 11px; color: #6c757d; opacity: 0.8;">
                        BattleMetrics Rust Analytics v1.0.1
                    </div>
                </div>
            `;
        }

        infoBox.innerHTML = content;

        Object.assign(infoBox.style, {
            position: "fixed",
            top: "70px",
            right: "20px",
            backgroundColor: "#2c3e50",
            color: "#fff",
            padding: "20px",
            borderRadius: "10px",
            zIndex: "9999",
            fontSize: "14px",
            maxWidth: "450px",
            maxHeight: "80vh",
            overflowY: "auto",
            boxShadow: "0 8px 25px rgba(0,0,0,0.3)",
            border: "1px solid #34495e",
            lineHeight: "1.4"
        });

        document.body.appendChild(infoBox);

        // Apply current visibility state
        updateButtonsVisibility();

        // Add toggle functionality for servers section
        window.toggleServers = () => {
            const serversList = document.getElementById('servers-list');
            const toggle = document.getElementById('servers-toggle');
            if (serversList && toggle) {
                if (serversList.style.display === 'none') {
                    serversList.style.display = 'block';
                    toggle.textContent = '▼';
                } else {
                    serversList.style.display = 'none';
                    toggle.textContent = '▶';
                }
            }
        };

        // Add toggle functionality for settings section
        window.toggleSettings = () => {
            const settingsContent = document.getElementById('settings-content');
            const toggle = document.getElementById('settings-toggle');
            if (settingsContent && toggle) {
                if (settingsContent.style.display === 'none') {
                    settingsContent.style.display = 'block';
                    toggle.textContent = '▼';
                } else {
                    settingsContent.style.display = 'none';
                    toggle.textContent = '▶';
                }
            }
        };

        // Add pagination functionality
        window.updateServersList = () => {
            const serversContent = document.getElementById('servers-content');
            const pageInfo = document.getElementById('page-info');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');

            if (!serversContent || allTopServers.length === 0) return;

            const serversPerPage = 10;
            const startIndex = currentServerPage * serversPerPage;
            const endIndex = Math.min(startIndex + serversPerPage, allTopServers.length);
            const currentServers = allTopServers.slice(startIndex, endIndex);

            // Update servers list
            let serversList = `<ol start="${startIndex + 1}" style="padding-left: 20px; margin: 0; font-family: 'Courier New', Courier, monospace; font-size: 13px;">`;
            currentServers.forEach(({ name, hours }) => {
                serversList += `<li style="margin-bottom: 4px; line-height: 1.3;">${name} — ${hours.toFixed(2)} hrs</li>`;
            });
            serversList += `</ol>`;
            serversContent.innerHTML = serversList;

            // Update pagination info and buttons
            if (pageInfo) {
                const totalPages = Math.ceil(allTopServers.length / serversPerPage);
                pageInfo.textContent = `Page ${currentServerPage + 1} of ${totalPages}`;
            }

            if (prevBtn) {
                prevBtn.disabled = currentServerPage === 0;
                prevBtn.style.opacity = currentServerPage === 0 ? '0.5' : '1';
            }

            if (nextBtn) {
                const totalPages = Math.ceil(allTopServers.length / serversPerPage);
                nextBtn.disabled = currentServerPage >= totalPages - 1;
                nextBtn.style.opacity = currentServerPage >= totalPages - 1 ? '0.5' : '1';
            }
        };

        window.nextServerPage = () => {
            console.log('[BMA Debug] nextServerPage called, currentPage:', currentServerPage, 'totalServers:', allTopServers.length);
            const totalPages = Math.ceil(allTopServers.length / 10);
            if (currentServerPage < totalPages - 1) {
                currentServerPage++;
                console.log('[BMA Debug] Moving to page:', currentServerPage);
                window.updateServersList();
            } else {
                console.log('[BMA Debug] Already at last page');
            }
        };

        window.previousServerPage = () => {
            console.log('[BMA Debug] previousServerPage called, currentPage:', currentServerPage);
            if (currentServerPage > 0) {
                currentServerPage--;
                console.log('[BMA Debug] Moving to page:', currentServerPage);
                window.updateServersList();
            } else {
                console.log('[BMA Debug] Already at first page');
            }
        };

        window.copyPlayerInfo = () => {
            const playerName = document.querySelector('#bmt-info-box').textContent.match(/Player: (.+)/)?.[1] || 'Unknown';
            const playerID = document.querySelector('#bmt-info-box').textContent.match(/ID: (.+)/)?.[1] || 'Unknown';
            const totalHours = document.querySelector('#bmt-info-box').textContent.match(/True Rust Hours: (.+)/)?.[1] || '0';

            // Extract both relative time and full date from the first seen section
            const fullText = document.querySelector('#bmt-info-box').textContent;
            const firstSeenMatch = fullText.match(/First Time Seen on Rust\s+(.*?)(?=Total Rust Servers Played|$)/s);
            let firstSeen = 'Unknown';

            if (firstSeenMatch) {
                const firstSeenContent = firstSeenMatch[1].trim();
                const lines = firstSeenContent.split('\n').map(line => line.trim()).filter(line => line);

                if (lines.length >= 2) {
                    // Both relative time and full date are available
                    firstSeen = `${lines[0]} (${lines[1]})`;
                } else if (lines.length === 1) {
                    // Only relative time available
                    firstSeen = lines[0];
                }
            }

            const totalServers = document.querySelector('#bmt-info-box').textContent.match(/Total Rust Servers Played: (\d+)/)?.[1] || '0';

            // Get current server info (most recently played)
            let currentServer = 'Not currently playing';
            
            if (allTopServers.length > 0) {
                // Find the server with the most recent lastSeen timestamp
                const mostRecentServer = allTopServers.reduce((most, current) => {
                    if (!most.lastSeen) return current;
                    if (!current.lastSeen) return most;
                    return new Date(current.lastSeen) > new Date(most.lastSeen) ? current : most;
                });
                currentServer = mostRecentServer.name;
            }

            // Full server list (top 10)
            let fullServerList = '';
            if (allTopServers.length > 0) {
                const top10 = allTopServers.slice(0, 10);
                fullServerList = top10.map((server, index) =>
                    `${index + 1}. ${server.name} — ${server.hours.toFixed(2)} hrs`
                ).join('\n');
            } else {
                fullServerList = 'No servers found';
            }

            // Get top 5 recent servers for "Recently Played" section with last seen
            let recentServers = '';
            if (allTopServers.length > 0) {
                const recent5 = allTopServers.slice(0, 5);
                recentServers = recent5.map((server, index) => {
                    let lastSeenText = '';
                    if (server.lastSeen) {
                        const lastSeenTime = toRelativeTime(server.lastSeen);
                        lastSeenText = ` (last seen ${lastSeenTime})`;
                    }
                    return `${index + 1}. ${server.name} — ${server.hours.toFixed(2)} hrs${lastSeenText}`;
                }).join('\n');
            } else {
                recentServers = 'No recent servers found';
            }

            const copyText = `\`\`\`Rust Player Profile\n\nPlayer: ${playerName}\nbattlemetrics id: ${playerID}\nTotal Rust Hours: ${totalHours}\nFirst Seen: ${firstSeen}\nTotal Servers Played: ${totalServers}\n\nCurrent Server: ${currentServer}\n\nTop 10 Servers by Hours:\n${fullServerList}\n\nRecently Played Servers:\n${recentServers}\n\nGenerated by BattleMetrics Rust Analytics\`\`\``;

            navigator.clipboard.writeText(copyText).then(() => {
                // Show success feedback
                const copyBtn = document.querySelector('button[onclick="copyPlayerInfo()"]');
                if (copyBtn) {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    copyBtn.style.background = '#28a745';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.style.background = '#28a745';
                    }, 2000);
                }
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = copyText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const copyBtn = document.querySelector('button[onclick="copyPlayerInfo()"]');
                if (copyBtn) {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }
            });
        };

        // Add event listeners for pagination buttons (Firefox compatibility)
        setTimeout(() => {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    console.log('[BMA Debug] Previous button clicked');
                    window.previousServerPage();
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    console.log('[BMA Debug] Next button clicked');
                    window.nextServerPage();
                });
            }
        }, 50);

        // Add debug console functions
        window.copyDebugLogs = () => {
            const debugText = debugConsole.getLogsAsText();
            navigator.clipboard.writeText(debugText).then(() => {
                const copyBtn = document.querySelector('button[onclick="copyDebugLogs()"]');
                if (copyBtn) {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    copyBtn.style.background = '#28a745';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.style.background = '#17a2b8';
                    }, 2000);
                }
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = debugText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            });
        };

        window.exportDebugLogs = () => {
            debugConsole.exportLogs();
        };

        window.clearDebugLogs = () => {
            debugConsole.clearLogs();
        };

        window.refreshDebugStats = () => {
            if (debugConsole) {
                debugConsole.updateDebugStats();
            }
        };

        window.testDebugConsole = () => {
            if (!debugConsole) {
                alert('Debug console not initialized!');
                return;
            }
            
            debugConsole.debug('Test debug message from user');
            debugConsole.info('Test info message from user');
            debugConsole.warn('Test warning message from user');
            debugConsole.error('Test error message from user');
            
            // Force refresh
            setTimeout(() => {
                debugConsole.updateDebugDisplay();
                debugConsole.updateDebugStats();
            }, 100);
        };



        // Initialize servers list if we have servers
        if (allTopServers.length > 0) {
            setTimeout(() => window.updateServersList(), 100);
        }

        // Initialize debug console display if enabled
        if (debugConsoleEnabled) {
            setTimeout(() => {
                debugConsole.updateDebugDisplay();
                debugConsole.updateDebugStats();
            }, 200);
        }

        // Add event listeners for settings toggles
        setTimeout(() => {
            const autoPullToggle = document.getElementById('auto-pull-toggle');
            const debugToggle = document.getElementById('debug-console-toggle');
            
            if (autoPullToggle) {
                autoPullToggle.addEventListener('change', (e) => {
                    autoPullEnabled = e.target.checked;
                    saveSettings();
                    debugLog('info', `Auto-pull ${autoPullEnabled ? 'enabled' : 'disabled'}`);
                    
                    if (autoPullEnabled) {
                        startAutoPull();
                    } else {
                        stopAutoPull();
                    }
                    
                    // Update button text
                    const button = document.getElementById(BUTTON_ID);
                    if (button) {
                        button.textContent = autoPullEnabled ? "Refresh Analytics" : "Get Rust Analytics";
                    }
                });
            }
            
            if (debugToggle) {
                debugToggle.addEventListener('change', (e) => {
                    debugConsoleEnabled = e.target.checked;
                    debugConsole.saveDebugSetting(debugConsoleEnabled);
                    debugLog('info', `Debug console ${debugConsoleEnabled ? 'enabled' : 'disabled'}`);
                    
                    // Show/hide debug console section
                    const debugSection = document.getElementById('debug-console-section');
                    if (debugSection) {
                        debugSection.style.display = debugConsoleEnabled ? 'block' : 'none';
                    }
                    
                    // Update debug display if enabled
                    if (debugConsoleEnabled) {
                        setTimeout(() => {
                            debugConsole.updateDebugDisplay();
                            debugConsole.updateDebugStats();
                        }, 100);
                    }
                });
            }
        }, 100);
    };

    function toRelativeTime(timestamp) {
        const now = new Date();
        const past = new Date(timestamp);
        const diffInSeconds = Math.round((now - past) / 1000);

        if (diffInSeconds < 30) return 'just now';

        // Years (with decimal precision)
        if (diffInSeconds >= 31536000) {
            const years = diffInSeconds / 31536000;
            return `${years.toFixed(1)} year${years >= 2 ? 's' : ''} ago`;
        }

        // Months (with decimal precision for less than a year)
        if (diffInSeconds >= 2592000) {
            const months = diffInSeconds / 2592000;
            return `${months.toFixed(1)} month${months >= 2 ? 's' : ''} ago`;
        }

        // Days (show exact days for less than a month)
        if (diffInSeconds >= 86400) {
            const days = Math.floor(diffInSeconds / 86400);
            return `${days} day${days > 1 ? 's' : ''} ago`;
        }

        // Hours
        if (diffInSeconds >= 3600) {
            const hours = Math.floor(diffInSeconds / 3600);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        }

        // Minutes
        if (diffInSeconds >= 60) {
            const minutes = Math.floor(diffInSeconds / 60);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        }

        return 'a moment ago';
    }

    const processDataInstantly = () => {
        const button = document.getElementById(BUTTON_ID);
        if (button) {
            button.disabled = true;
            button.textContent = "Loading...";
        }
        removeResults();

        try {
            const dataScript = document.getElementById('storeBootstrap');
            if (!dataScript) {
                throw new Error("No data available");
            }

            const pageData = JSON.parse(dataScript.textContent);
            const urlPlayerID = window.location.pathname.split('/players/')[1]?.split('/')[0];
            
            if (!urlPlayerID) throw new Error("Invalid player URL format.");
            if (!pageData?.state?.players?.serverInfo?.[urlPlayerID]) {
                throw new Error("Player data not found");
            }

            const serverInfo = pageData.state.players.serverInfo[urlPlayerID];
            const serverData = pageData.state.servers.servers;

            // Get player name
            let playerName = 'Unknown Player';
            if (pageData.state.players.players && pageData.state.players.players[urlPlayerID]) {
                playerName = pageData.state.players.players[urlPlayerID].name;
            } else {
                const titleElement = document.querySelector('h1, .player-name, [data-testid="player-name"]');
                if (titleElement) {
                    playerName = titleElement.textContent.trim();
                }
            }

            // Process server data
            let totalSeconds = 0;
            let earliestRustFirstSeen = null;
            const rustServersPlayed = [];

            if (serverInfo) {
                Object.values(serverInfo).forEach(playerStats => {
                    const serverId = playerStats.serverId;
                    const serverDetails = serverData[serverId];
                    if (serverDetails && serverDetails.game_id === 'rust') {
                        const timePlayed = playerStats.timePlayed || 0;
                        totalSeconds += timePlayed;

                        if (earliestRustFirstSeen === null || playerStats.firstSeen < earliestRustFirstSeen) {
                            earliestRustFirstSeen = playerStats.firstSeen;
                        }

                        rustServersPlayed.push({
                            name: serverDetails.name || "Unnamed Server",
                            seconds: timePlayed,
                            lastSeen: playerStats.lastSeen
                        });
                    }
                });
            }

            const totalHours = (totalSeconds / 3600).toFixed(2);

            let firstSeenData;
            if (earliestRustFirstSeen) {
                const firstSeenDate = new Date(earliestRustFirstSeen);
                const relativeTime = toRelativeTime(earliestRustFirstSeen);
                const fullDateString = firstSeenDate.toLocaleString();
                firstSeenData = { relative: relativeTime, full: fullDateString };
            } else {
                firstSeenData = { relative: "N/A", full: null };
            }

            rustServersPlayed.sort((a, b) => b.seconds - a.seconds);
            const processedServers = rustServersPlayed.map(s => ({
                name: s.name,
                hours: s.seconds / 3600,
                lastSeen: s.lastSeen
            }));

            showInfoBox(playerName, urlPlayerID, totalHours, firstSeenData, processedServers, rustServersPlayed.length, false, "", earliestRustFirstSeen);

            // Reset button
            if (button) {
                button.disabled = false;
                button.textContent = "Get Rust Analytics";
            }

        } catch (e) {
            debugLog('error', 'Script processing error in processDataInstantly', e);
            const firstSeenData = { relative: "Error", full: null };
            showInfoBox("Unknown Player", "N/A", "Error", firstSeenData, [], 0, true, e.message);

            if (button) {
                button.disabled = false;
                button.textContent = "Get Rust Analytics";
            }
        }
    };

    const calculateOrReload = (retryCount = 0, isAutoLoad = false) => {
        const button = document.getElementById(BUTTON_ID);
        if (button) {
            button.disabled = true;
            button.textContent = retryCount > 0 ? `Waiting for data... (${retryCount}/5)` : "Fetching data...";
        }
        removeResults();

        // Helper function to check if data is ready
        const isDataReady = () => {
            const dataScript = document.getElementById('storeBootstrap');
            if (!dataScript) return { ready: false, reason: "Missing BattleMetrics data script" };

            try {
                const pageData = JSON.parse(dataScript.textContent);

                // Debug logging
                debugLog('debug', 'pageData structure analysis', {
                    hasState: !!pageData?.state,
                    hasPlayers: !!pageData?.state?.players,
                    hasServerInfo: !!pageData?.state?.players?.serverInfo,
                    serverInfoKeys: pageData?.state?.players?.serverInfo ? Object.keys(pageData.state.players.serverInfo) : [],
                    hasServers: !!pageData?.state?.servers,
                    hasServersData: !!pageData?.state?.servers?.servers,
                    currentURL: window.location.href
                });

                if (!pageData || !pageData.state) {
                    return { ready: false, reason: "Invalid page data structure" };
                }

                if (!pageData.state.players || !pageData.state.players.serverInfo) {
                    return { ready: false, reason: "Player data not available" };
                }

                const serverInfoKeys = Object.keys(pageData.state.players.serverInfo);
                if (serverInfoKeys.length === 0) {
                    return { ready: false, reason: "No server information found" };
                }

                // Check if the data matches the current URL player ID
                const urlPlayerID = window.location.pathname.split('/players/')[1]?.split('/')[0];
                if (urlPlayerID && !pageData.state.players.serverInfo[urlPlayerID]) {
                    return { ready: false, reason: "Data doesn't match current player" };
                }

                if (!pageData.state.servers || !pageData.state.servers.servers) {
                    return { ready: false, reason: "Server data not available" };
                }

                return { ready: true, pageData };
            } catch (e) {
                return { ready: false, reason: `Data parsing error: ${e.message}` };
            }
        };

        const dataCheck = isDataReady();

        // If data isn't ready, retry up to 8 times (longer wait for navigation)
        if (!dataCheck.ready) {
            if (retryCount < 8) {
                debugLog('warn', `${dataCheck.reason}, retrying in 2 seconds... (attempt ${retryCount + 1}/8)`);
                setTimeout(() => calculateOrReload(retryCount + 1), 2000);
                return;
            } else {
                // After 8 retries, try to force reload the page data
                debugLog('error', 'Data not ready after retries, attempting page reload...');
                sessionStorage.setItem(RELOAD_FLAG, 'true');
                window.location.reload();
                return;
            }
        }

        // Data is ready, proceed with processing
        try {
            const urlPlayerID = window.location.pathname.split('/players/')[1]?.split('/')[0];
            if (!urlPlayerID) throw new Error("Invalid player URL format.");

            const pageData = dataCheck.pageData;
            const serverInfoKeys = Object.keys(pageData.state.players.serverInfo);

            const dataPlayerID = serverInfoKeys[0];

            // Get player name for display
            let playerName = 'Unknown Player';
            if (pageData.state.players.players && pageData.state.players.players[urlPlayerID]) {
                playerName = pageData.state.players.players[urlPlayerID].name;
            } else {
                // Try to get name from page title or other sources
                const titleElement = document.querySelector('h1, .player-name, [data-testid="player-name"]');
                if (titleElement) {
                    playerName = titleElement.textContent.trim();
                }
            }

            // Update current player tracking and clear cache if player changed
            if (currentPlayerID !== urlPlayerID) {
                cachedPlayerData = null;
                currentPlayerID = urlPlayerID;
            }

            if (urlPlayerID === dataPlayerID) {
                const serverInfo = pageData.state.players.serverInfo[urlPlayerID];
                const serverData = pageData.state.servers.servers;

                if (!serverInfo) {
                    // If auto-loading and no server info, reload to get fresh data
                    if (isAutoLoad && retryCount === 0) {
                        console.log("BM Script: Auto-load detected no server info, reloading for fresh data...");
                        sessionStorage.setItem(RELOAD_FLAG, 'true');
                        window.location.reload();
                        return;
                    }
                    const firstSeenData = { relative: "N/A", full: null };
                    showInfoBox(playerName, urlPlayerID, "0.00", firstSeenData, [], 0);
                } else {
                    let totalSeconds = 0;
                    let earliestRustFirstSeen = null;
                    const rustServersPlayed = [];

                    Object.values(serverInfo).forEach(playerStats => {
                        const serverId = playerStats.serverId;
                        const serverDetails = serverData[serverId];
                        if (serverDetails && serverDetails.game_id === 'rust') {
                            const timePlayed = playerStats.timePlayed || 0;
                            totalSeconds += timePlayed;

                            if (earliestRustFirstSeen === null || playerStats.firstSeen < earliestRustFirstSeen) {
                                earliestRustFirstSeen = playerStats.firstSeen;
                            }

                            rustServersPlayed.push({
                                name: serverDetails.name || "Unnamed Server",
                                seconds: timePlayed,
                                lastSeen: playerStats.lastSeen
                            });
                        }
                    });

                    const totalHours = (totalSeconds / 3600).toFixed(2);

                    // If auto-loading and hours are 0, reload to get fresh data
                    if (isAutoLoad && parseFloat(totalHours) === 0 && retryCount === 0) {
                        console.log("BM Script: Auto-load detected 0 hours, reloading for fresh data...");
                        sessionStorage.setItem(RELOAD_FLAG, 'true');
                        window.location.reload();
                        return;
                    }

                    let firstSeenData;
                    if (earliestRustFirstSeen) {
                        const firstSeenDate = new Date(earliestRustFirstSeen);
                        const relativeTime = toRelativeTime(earliestRustFirstSeen);
                        const fullDateString = firstSeenDate.toLocaleString();
                        firstSeenData = { relative: relativeTime, full: fullDateString };
                    } else {
                        firstSeenData = { relative: "N/A", full: null };
                    }

                    rustServersPlayed.sort((a, b) => b.seconds - a.seconds);
                    const processedServers = rustServersPlayed.map(s => ({
                        name: s.name,
                        hours: s.seconds / 3600,
                        lastSeen: s.lastSeen
                    }));

                    showInfoBox(playerName, urlPlayerID, totalHours, firstSeenData, processedServers, rustServersPlayed.length, false, "", earliestRustFirstSeen);

                    // Reset button on success
                    if (button) {
                        button.disabled = false;
                        button.textContent = "Get Rust Analytics";
                    }
                }
            } else {
                // Data mismatch - this means we have stale data from previous player
                console.log("BM Script: Data mismatch detected. Player ID from URL:", urlPlayerID, "Data ID:", dataPlayerID);

                // Don't use stale data - wait for correct data or force reload
                if (retryCount < 5) {
                    console.log(`BM Script: Waiting for correct player data... (attempt ${retryCount + 1}/5)`);
                    setTimeout(() => calculateOrReload(retryCount + 1), 2000);
                    return;
                } else {
                    // After retries, force page reload to get fresh data
                    console.log("BM Script: Data still mismatched after retries. Auto-refreshing to load correct user data.");
                    const firstSeenData = { relative: "Loading...", full: null };
                    showInfoBox(playerName, urlPlayerID, "Loading...", firstSeenData, [], 0, false, "Loading data for current user...");
                    sessionStorage.setItem(RELOAD_FLAG, 'true');
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                    return;
                }
            }
        } catch (e) {
            console.error("BM Script Error:", e);
            const firstSeenData = { relative: "Error", full: null };
            showInfoBox("Unknown Player", "N/A", "Error", firstSeenData, [], 0, true, e.message);

            // Reset button
            if (button) {
                button.disabled = false;
                button.textContent = "Get Rust Analytics";
            }
        }
    };

    const createButton = () => {
        // Remove existing buttons if they exist
        const existingBtn = document.getElementById(BUTTON_ID);
        const existingToggleBtn = document.getElementById(TOGGLE_BUTTON_ID);
        if (existingBtn) existingBtn.remove();
        if (existingToggleBtn) existingToggleBtn.remove();

        // Verify we're on a player page before creating button
        if (!window.location.href.includes('/players/')) {
            console.log("BM Script: Not on player page, skipping button creation");
            return;
        }

        console.log("BM Script: Creating analytics button");

        const btn = document.createElement("button");
        btn.id = BUTTON_ID;
        btn.textContent = autoPullEnabled ? "Refresh Analytics" : "Get Rust Analytics";
        btn.onclick = calculateOrReload;
        Object.assign(btn.style, {
            position: "fixed",
            top: "20px",
            right: "80px", // Moved left to make room for toggle button
            zIndex: "9999",
            padding: "10px 20px",
            backgroundColor: "#007bff",
            color: "#fff",
            border: "none",
            borderRadius: "5px",
            cursor: "pointer",
            fontFamily: "Arial, sans-serif",
            fontSize: "14px",
            fontWeight: "bold"
        });
        
        // Ensure button is added to DOM
        try {
            document.body.appendChild(btn);
            console.log("BM Script: Analytics button created successfully");
        } catch (error) {
            console.error("BM Script: Error creating button:", error);
            return;
        }

        // Create toggle button
        createToggleButton();

        // Apply current visibility state
        updateButtonsVisibility();
        
        // Verify button is visible
        setTimeout(() => {
            const verifyBtn = document.getElementById(BUTTON_ID);
            if (!verifyBtn) {
                console.log("BM Script: Button verification failed, retrying...");
                setTimeout(createButton, 1000);
            }
        }, 500);
    };

    const waitForDataAndCreateButton = (attempt = 0) => {
        const maxAttempts = 15; // Wait longer for navigation

        // Check if data is ready
        const dataScript = document.getElementById('storeBootstrap');
        if (dataScript) {
            try {
                const pageData = JSON.parse(dataScript.textContent);
                if (pageData && pageData.state && pageData.state.players && pageData.state.players.serverInfo) {
                    const serverInfoKeys = Object.keys(pageData.state.players.serverInfo);
                    if (serverInfoKeys.length > 0 && pageData.state.servers && pageData.state.servers.servers) {
                        console.log("BM Script: Data is ready, creating button");
                        createButton();
                        return;
                    }
                }
            } catch (e) {
                // Data not ready yet
            }
        }

        // If data not ready and we haven't exceeded max attempts, try again
        if (attempt < maxAttempts) {
            console.log(`BM Script: Waiting for data to load... (${attempt + 1}/${maxAttempts})`);
            setTimeout(() => waitForDataAndCreateButton(attempt + 1), 1000);
        } else {
            console.log("BM Script: Data not ready after waiting, creating button anyway (will auto-reload when clicked)");
            createButton();
        }
    };

    const checkForURLChange = () => {
        const currentURL = window.location.href;
        if (currentURL !== lastURL) {
            console.log("BM Script: URL change detected from", lastURL, "to", currentURL);
            lastURL = currentURL;
            
            // Clear cached data when navigating to a different player
            const newPlayerID = currentURL.split('/players/')[1]?.split('/')[0];
            if (newPlayerID && newPlayerID !== currentPlayerID) {
                console.log("BM Script: Player changed, clearing cache");
                cachedPlayerData = null;
                currentPlayerID = newPlayerID;
            }
            
            removeResults();

            // Only create button on player pages
            if (currentURL.includes('/players/')) {
                // Use multiple attempts to ensure button creation after navigation
                const createButtonWithRetry = (attempts = 0) => {
                    if (attempts > 5) return; // Max 5 attempts
                    
                    setTimeout(() => {
                        if (!document.getElementById(BUTTON_ID)) {
                            console.log(`BM Script: Creating button after navigation (attempt ${attempts + 1})`);
                            createButton();
                            createToggleButton();
                            
                            // Verify button was created, retry if not
                            setTimeout(() => {
                                if (!document.getElementById(BUTTON_ID)) {
                                    createButtonWithRetry(attempts + 1);
                                }
                            }, 500);
                        }
                    }, 300 + (attempts * 200)); // Increasing delay for each attempt
                };
                
                createButtonWithRetry();
                
                // Don't auto-reload on every navigation - let user choose when to load data
                // This prevents the constant reloading issue you mentioned
            } else {
                // Remove buttons when not on player pages
                const existingBtn = document.getElementById(BUTTON_ID);
                const existingToggleBtn = document.getElementById(TOGGLE_BUTTON_ID);
                if (existingBtn) existingBtn.remove();
                if (existingToggleBtn) existingToggleBtn.remove();
            }
        }
    };

    const initializePageObserver = () => {
        // Watch for URL changes (navigation between profiles)
        const urlObserver = new MutationObserver(() => {
            checkForURLChange();
        });

        // Watch for content changes
        const contentObserver = new MutationObserver((mutations) => {
            // Check if storeBootstrap script was added/modified
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.id === 'storeBootstrap') {
                        console.log("BM Script: storeBootstrap script detected, checking for button creation");
                        if (window.location.href.includes('/players/') && !document.getElementById(BUTTON_ID)) {
                            setTimeout(createButton, 500);
                        }
                    }
                });
            });

            // Ensure button exists after content changes on player pages
            if (window.location.href.includes('/players/') && !document.getElementById(BUTTON_ID)) {
                setTimeout(() => {
                    if (!document.getElementById(BUTTON_ID)) {
                        createButton();
                    }
                }, 1000);
            }
        });

        const targetNode = document.getElementById('content-container') || document.body;
        urlObserver.observe(targetNode, { childList: true, subtree: true });
        contentObserver.observe(document.body, { childList: true });

        // Also check for URL changes periodically
        setInterval(checkForURLChange, 1000);

        // Listen for browser navigation events
        window.addEventListener('popstate', checkForURLChange);

        // Override pushState and replaceState to catch programmatic navigation
        const originalPushState = history.pushState;
        const originalReplaceState = history.replaceState;

        history.pushState = function () {
            originalPushState.apply(history, arguments);
            setTimeout(checkForURLChange, 100);
        };

        history.replaceState = function () {
            originalReplaceState.apply(history, arguments);
            setTimeout(checkForURLChange, 100);
        };
    };

    // Initialize everything
    const initialize = () => {
        console.log("BM Script: Initializing Rust Analytics...");
        
        // Only create button if we're on a player page
        if (window.location.href.includes('/players/')) {
            console.log("BM Script: On player page, creating button");
            createButton();
            
            // Don't auto-reload on initial load - let user choose when to get data
            // This prevents the constant reloading issue you mentioned
        }

        initializePageObserver();

        // If this was after a reload (user clicked button), process data
        if (sessionStorage.getItem(RELOAD_FLAG) === 'true') {
            sessionStorage.removeItem(RELOAD_FLAG);
            console.log("BM Script: Processing data after user-initiated reload...");
            setTimeout(() => {
                processDataInstantly();
            }, 500);
        }
        
        console.log("BM Script: Initialization complete");
    };

    // Wait for page to be ready with multiple initialization attempts
    const initializeWhenReady = () => {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initialize, 500);
            });
        } else {
            // Page already loaded, initialize immediately
            initialize();
        }
    };
    
    initializeWhenReady();
    
    // Fallback: Check periodically if we're on a player page but don't have a button
    setInterval(() => {
        if (window.location.href.includes('/players/') && !document.getElementById(BUTTON_ID)) {
            console.log("BM Script: Fallback button creation triggered");
            createButton();
        }
    }, 5000); // Check every 5 seconds

    // Auto-reload fallback: If we're on a player page but button isn't showing after navigation
    setInterval(() => {
        const isPlayerPage = window.location.href.includes('/players/');
        const hasButton = document.getElementById(BUTTON_ID);
        const hasToggleButton = document.getElementById(TOGGLE_BUTTON_ID);
        
        if (isPlayerPage && !hasButton && !hasToggleButton) {
            console.log('BM Script: UI missing on player page, auto-reloading...');
            // Set a flag to prevent infinite reloads
            const reloadFlag = 'bmt_auto_reload_' + Date.now();
            if (!sessionStorage.getItem(reloadFlag)) {
                sessionStorage.setItem(reloadFlag, 'true');
                // Clear old reload flags
                Object.keys(sessionStorage).forEach(key => {
                    if (key.startsWith('bmt_auto_reload_') && key !== reloadFlag) {
                        sessionStorage.removeItem(key);
                    }
                });
                setTimeout(() => {
                    window.location.reload();
                }, 1000);
            }
        }
    }, 10000); // Check every 10 seconds

    // Initialize auto-pull if enabled
    if (autoPullEnabled) {
        debugLog('info', 'Auto-pull is enabled, starting auto-pull functionality');
        startAutoPull();
    } else {
        debugLog('info', 'Auto-pull is disabled');
    }
})();